<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
	<title>Java Advanced</title>
	<link rel="stylesheet" type="text/css" href="../assets/css/bootstrap.min.css">
	<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
	<style>
		body{
			background-color:black;
			font-size:200%;
		}
    
        td, th{ padding:10px; }

        .part{
            background-color:black;
            color:cyan;
            padding: 10px;
            border-radius: 10px;
            font-weight:bold;
			font-size:150%;
        }
        
        .def{
            background-color:#2c2d19;
            color:white;
            padding:20px;
            margin:10px;
            border-radius:20px;
        }        

        .code{
            background-color:#355367;
            font-weight:bold;
            color:white;
            padding:20px;
            margin:30px;
            border-radius:20px;
        }

        .mainPoint{
            font-weight: bold;
            text-decoration: underline;
        }
        
        .panel{ margin:20px; }

        .panel-body{ background-color: #e3ded1; }

        .container{ width:95%; }
	</style>
</head>

<body>
<br/>
<div class="container">
    <div class="panel panel-primary">
        <div class="panel-heading"><h1 align="center" id="tableOfContent">Java Advanced</h1>
            <h3 align="center">(Source: <a href="https://www.tutorialspoint.com/java/java_data_structures.htm"><font color="blue">tutorialspoint</font></a>)</h3>
        </div>
        <div class="panel-body" style="text-align: center;">
            <h2><a href="#java_collections">Collections</a></h2>
            <h2><a href="#java_generics">Generics</a></h2>
            <h2><a href="#java_serialization">Serialization</a></h2>
            <h2><a href="#java_networking">Networking</a></h2>
            <h2><a href="#java_sending_email">Sending Email</a></h2>
            <h2><a href="#java_multithreading">Multithreading</a></h2>
            <h2><a href="#java_applet_basics">Applet Basics</a></h2>
            <h2><a href="#java_documentation">Documentation</a></h2>
        </div>
    </div>

    <div class="panel panel-primary">    
        <div class="panel-heading"><h1 align="center">Java Advanced - Content</h1></div>
        <div class="panel-body">
            <span class="part" id="java_collections">Collections</span>  (source: <a href="https://www.tutorialspoint.com/java/java_collections.htm">tutorialspoint</a>)<br/><br/>
            <p>Prior to Java 2, Java provided ad hoc classes such as <b>Dictionary</b>, <b>Vector</b>, <b>Stack</b>, and <b>Properties</b> to store and manipulate groups of 
                objects. Although these classes were quite useful, they lacked a central, unifying theme. Thus, the way that you used <b>Vector</b> was 
                different from the way that you used <b>Properties</b>.</p>

            <p>The collections framework was designed to meet several goals, such as</p>
            <ul>
                <li>The framework had to be high-performance. The implementations for the fundamental collections (<b>dynamic arrays</b>, <b>linked lists</b>, 
                    <b>trees</b>, and <b>hashtables</b>) were to be highly efficient.</li>
                <li>The framework had to allow different types of collections to work in a similar manner and with a high degree of interoperability.</li>
                <li>The framework had to extend and/or adapt a collection easily.</li>
            </ul>

            <p>A collections framework is a unified architecture for representing and manipulating collections. All collections frameworks contain the following</p>
            <ul>
                <li><b>Interfaces</b> - These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details 
                    of their representation. In object-oriented languages, interfaces generally form a hierarchy.</li>
                <li><b>Implementations</b>, i.e., <b>Classes</b> - These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures.</li>
                <li><b>Algorithms</b> - These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. 
                    The algorithms are said to be polymorphic: that is, the same method can be used on many different implementations of the appropriate collection interface.</li>
            </ul>
            <br/><p align="right">(<a href="#tableOfContent">Table of Content</a>)</p><hr/>
            <!-- *************************************************************************** -->
            <!-- *************************************************************************** -->
            <span class="part" id="java_generics">Generics</span>  (source: <a href="https://www.tutorialspoint.com/java/java_generics.htm">tutorialspoint</a>)<br/><br/>
            <p>It would be nice if we could write a single sort method that could sort the elements in an Integer array, a String array, or an array of any 
                type that supports ordering.</p>
                    
            <p>Java <b>Generic</b> methods and generic classes enable programmers to specify, with a single method declaration, a set of related methods, or 
                with a single class declaration, a set of related types, respectively.</p>
                    
            <p>Generics also provide compile-time type safety that allows programmers to catch invalid types at compile time.</p>

            <h3 class="mainPoint">Generic Methods</h3>
            <p>You can write a single generic method declaration that can be called with arguments of different types. Based on the types of the arguments 
                passed to the generic method, the compiler handles each method call appropriately. Following are the rules to define Generic Methods</p>
            <ul>
                <li>All generic method declarations have a type parameter section delimited by angle brackets (<font color="red"><b>&lt;</b></font> and 
                    <font color="red"><b>&gt;</b></font>) that precedes the method's return type ( <font color="red"><b>&lt;</b></font>E<font color="red"><b>&gt;</b></font> in the next example).</li>
                <li>Each type parameter section contains one or more type parameters separated by commas. A type parameter, also known as a type variable, 
                    is an identifier that specifies a generic type name.</li>
                <li>The type parameters can be used to declare the return type and act as placeholders for the types of the arguments passed to the generic 
                    method, which are known as actual type arguments.</li>
                <li>A generic method's body is declared like that of any other method. Note that type parameters can represent only reference types, 
                    not primitive types (like int, double and char).</li>
            </ul>
            <p class="mainPoint">Example</p>
<pre class="code">
public class GenericMethodTest {
    // generic method printArray
    public static < E > void printArray( E[] inputArray ) {
        // Display array elements
        for(E element : inputArray) {
            System.out.printf("%s ", element);
        }
        System.out.println();
    }
    
    public static void main(String args[]) {
        // Create arrays of Integer, Double and Character
        Integer[] intArray = { 1, 2, 3, 4, 5 };
        Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
        Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };
    
        System.out.println("Array integerArray contains:");
        printArray(intArray);   // pass an Integer array
    
        System.out.println("\nArray doubleArray contains:");
        printArray(doubleArray);   // pass a Double array
    
        System.out.println("\nArray characterArray contains:");
        printArray(charArray);   // pass a Character array
    }
}
</pre>    
            <p>Output:</p>        
<pre class="code">
Array integerArray contains:
1 2 3 4 5 

Array doubleArray contains:
1.1 2.2 3.3 4.4 

Array characterArray contains:
H E L L O
</pre>            
            <br/><p align="right">(<a href="#tableOfContent">Table of Content</a>)</p><hr/>
            <!-- *************************************************************************** -->
            <!-- *************************************************************************** -->
            <span class="part" id="java_serialization">Serialization</span>  (source: <a href="https://www.tutorialspoint.com/java/java_serialization.htm">tutorialspoint</a>)<br/><br/>
            <p>Java provides a mechanism, called object serialization where an object can be represented as a sequence of bytes that 
                includes the object's data as well as information about the object's type and the types of data stored in the object.</p>
            
            <p>After a serialized object has been written into a file, it can be read from the file and deserialized that is, the type 
                information and bytes that represent the object and its data can be used to recreate the object in memory.</p>
            
            <p>Most impressive is that the entire process is JVM independent, meaning an object can be serialized on one platform and deserialized 
                on an entirely different platform.</p>
            
            <p>Classes <font color="red"><b>ObjectInputStream</b></font> and <font color="red"></b>ObjectOutputStream</b></font> are high-level streams that contain the methods for serializing and deserializing an object.</p>

            <p class="mainPoint">Example</p>
<pre class="code">
public class Employee implements java.io.Serializable {
    public String name;
    public String address;
    public transient int SSN;
    public int number;
    
    public void mailCheck() {
        System.out.println("Mailing a check to " + name + " " + address);
    }
}
</pre>            
            <div class="def">
                <p>Notice that for a class to be serialized successfully, two conditions must be met</p>
                <ul>
                    <li>The class must implement the java.io.Serializable interface.</li>
                    <li>All of the fields in the class must be serializable. If a field is not serializable, it must be marked 
                        <font color="yellow">transient</font>.</li>
                </ul>
            </div>

            <h3 class="mainPoint">Serializing an Object</h3>
            <div class="def"><b><u>Note</u></b> - When serializing an object to a file, the standard convention in Java is to give the file a 
                <font color="red"><b>.ser</b></font> extension.</div>
<pre class="code">
import java.io.*;
public class SerializeDemo {

    public static void main(String [] args) {
        Employee e = new Employee();
        e.name = "Reyan Ali";
        e.address = "Phokka Kuan, Ambehta Peer";
        e.SSN = 11122333;
        e.number = 101;
        
        try {
            FileOutputStream fileOut =
            new FileOutputStream("/tmp/employee.ser");
            ObjectOutputStream out = new ObjectOutputStream(fileOut);
            out.writeObject(e);
            out.close();
            fileOut.close();
            System.out.printf("Serialized data is saved in /tmp/employee.ser");
        } catch (IOException i) {
            i.printStackTrace();
        }
    }
}    
</pre>                
            <h3 class="mainPoint">Deserializing an Object</h3>
            <p class="mainPoint">Example</p>
<pre class="code">
import java.io.*;
public class DeserializeDemo {

    public static void main(String [] args) {
        Employee e = null;
        try {
            FileInputStream fileIn = new FileInputStream("/tmp/employee.ser");
            ObjectInputStream in = new ObjectInputStream(fileIn);
            e = (Employee) in.readObject();
            in.close();
            fileIn.close();
        } catch (IOException i) {
            i.printStackTrace();
            return;
        } catch (ClassNotFoundException c) {
            System.out.println("Employee class not found");
            c.printStackTrace();
            return;
        }
        
        System.out.println("Deserialized Employee...");
        System.out.println("Name: " + e.name);
        System.out.println("Address: " + e.address);
        System.out.println("SSN: " + e.SSN);
        System.out.println("Number: " + e.number);
    }
}
</pre>            
            <p>Output</p>
<pre class="code">
Deserialized Employee...

Name: Reyan Ali

Address:Phokka Kuan, Ambehta Peer

SSN: 0

Number:101  
</pre>          
            <p>Here are following important points to be noted</p>
            <ul>
                <li>The <b>try/catch</b> block tries to catch a ClassNotFoundException, which is declared by the readObject() method. 
                    For a JVM to be able to deserialize an object, it must be able to find the bytecode for the class. If the JVM 
                    can't find a class during the deserialization of an object, it throws a ClassNotFoundException.</li>
                <li>Notice that the return value of readObject() is cast to an Employee reference.</li>
                <li>The value of the SSN field was 11122333 when the object was serialized, but because the field is <font color="red"><b>transient</b></font>, this value was not 
                    sent to the output stream. The SSN field of the deserialized Employee object is 0.</li>
            </ul>

            <br/><p align="right">(<a href="#tableOfContent">Table of Content</a>)</p><hr/>
            <!-- *************************************************************************** -->
            <!-- *************************************************************************** -->
            <span class="part" id="java_networking">Networking</span>  (source: <a href="https://www.tutorialspoint.com/java/java_networking.htm">tutorialspoint</a>)<br/><br/>
            <p>The term <i>network programming</i> refers to writing programs that execute across multiple devices (computers), 
                in which the devices are all connected to each other using a network.</p>
                    
            <p>The <font color="red"><b>java.net package</b></font> of the <b>J2SE APIs</b> contains a collection of classes and interfaces that provide the low-level 
                communication details, allowing you to write programs that focus on solving the problem at hand.</p>
                    
            <p>The <font color="red"><b>java.net</b></font> package provides support for the two common network protocols</p>
            <ul>
                <li><b>TCP</b> - TCP stands for Transmission Control Protocol, which allows for reliable communication between two applications. TCP is typically used over 
                    the Internet Protocol, which is referred to as TCP/IP.</li>
                <li><b>UDP</b> - UDP stands for User Datagram Protocol, a connection-less protocol that allows for packets of data to be transmitted between applications.</li>
            </ul>

            <p>There are two important subjects</p>
            <ul>
                <li><b>Socket Programming</b> - This is the most widely used concept in Networking and it has been explained in very detail.</li>
                <li><b>URL Processing</b> - This would be covered separately. Click here to learn about URL Processing in Java language.</li>
            </ul>

            <br/><p align="right">(<a href="#tableOfContent">Table of Content</a>)</p><hr/>
            <!-- *************************************************************************** -->
            <!-- *************************************************************************** -->
            <span class="part" id="java_sending_email">Sending Email</span>  (source: <a href="https://www.tutorialspoint.com/java/java_sending_email.htm">tutorialspoint</a>)<br/><br/>
            <p>To send an e-mail using your Java Application is simple enough but to start with you should have 
                <b>JavaMail API</b> and <b>Java Activation Framework (JAF)</b> installed on your machine.</p>

            <h3 class="mainPoint">Send a Simple E-mail</h3>
            <p>Here is an example to send a simple e-mail from your machine. It is assumed that your <b>localhost</b> is connected to the Internet 
                and capable enough to send an e-mail.</p>
            <p class="mainPoint">Example</p>
<pre class="code">
// File Name SendEmail.java

import java.util.*;
import javax.mail.*;
import javax.mail.internet.*;
import javax.activation.*;

public class SendEmail {

    public static void main(String [] args) {    
        // Recipient's email ID needs to be mentioned.
        String to = "abcd@gmail.com";

        // Sender's email ID needs to be mentioned
        String from = "web@gmail.com";

        // Assuming you are sending email from localhost
        String host = "localhost";

        // Get system properties
        Properties properties = System.getProperties();

        // Setup mail server
        properties.setProperty("mail.smtp.host", host);

        // Get the default Session object.
        Session session = Session.getDefaultInstance(properties);

        try {
            // Create a default MimeMessage object.
            MimeMessage message = new MimeMessage(session);

            // Set From: header field of the header.
            message.setFrom(new InternetAddress(from));

            // Set To: header field of the header.
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));

            // Set Subject: header field
            message.setSubject("This is the Subject Line!");

            // Now set the actual message
            message.setText("This is actual message");

            // Send message
            Transport.send(message);
            System.out.println("Sent message successfully....");
        } catch (MessagingException mex) {
            mex.printStackTrace();
        }
    }
}   
</pre>
            <p>Compile and run this program to send a simple e-mail</p>
            <p>Output</p>
<pre class="code">
$ java SendEmail
Sent message successfully....
</pre>            
            <br/><p align="right">(<a href="#tableOfContent">Table of Content</a>)</p><hr/>
            <!-- *************************************************************************** -->
            <!-- *************************************************************************** -->
            <span class="part" id="java_multithreading">Multithreading</span>  (source: <a href="https://www.tutorialspoint.com/java/java_multithreading.htm">tutorialspoint</a>)<br/><br/>
            <p>Java is a <i>multi-threaded programming language</i> which means we can develop multi-threaded program using Java. A multi-threaded program 
                contains two or more parts that can run concurrently and each part can handle a different task at the same time making optimal use 
                of the available resources specially when your computer has multiple CPUs.</p>
            
            <h3 class="mainPoint">Life Cycle of a Thread</h3>
            <p>A thread goes through various stages in its life cycle. For example, a thread is born, started, runs, and then dies. The following diagram 
                shows the complete life cycle of a thread.</p>
            <p align="center"><img src="JavaAdvanced/img/Thread_Life_Cycle.jpg"/></p>
            <p>Following are the stages of the life cycle</p>

            <ul>
                <li><b>New</b> - A new thread begins its life cycle in the new state. It remains in this state until the program starts the thread. 
                    It is also referred to as a <b>born thread</b>.</li>
                <li><b>Runnable</b> - After a newly born thread is started, the thread becomes runnable. A thread in this state is considered to be executing its task.</li>
                <li><b>Waiting</b> - Sometimes, a thread transitions to the waiting state while the thread waits for another thread to perform a task. A thread 
                    transitions back to the runnable state only when another thread signals the waiting thread to continue executing.</li>
                <li><b>Timed Waiting</b> - A runnable thread can enter the timed waiting state for a specified interval of time. A thread in this state transitions 
                    back to the runnable state when that time interval expires or when the event it is waiting for occurs.</li>
                <li><b>Terminated (Dead)</b> - A runnable thread enters the terminated state when it completes its task or otherwise terminates.</li>
            </ul>

            <h3 class="mainPoint">Thread Priorities</h3>
            <p>Every Java thread has a priority that helps the operating system determine the order in which threads are scheduled.</p>
            
            <p>Java thread priorities are in the range between MIN_PRIORITY (a constant of 1) and MAX_PRIORITY (a constant of 10). By default, every thread is given priority NORM_PRIORITY (a constant of 5).</p>
            
            <p>Threads with higher priority are more important to a program and should be allocated processor time before lower-priority threads. However, thread 
                priorities cannot guarantee the order in which threads execute and are very much platform dependent.</p>

            <br/><p align="right">(<a href="#tableOfContent">Table of Content</a>)</p><hr/>
            <!-- *************************************************************************** -->
            <!-- *************************************************************************** -->
            <span class="part" id="java_applet_basics">Applet Basics</span>  (source: <a href="https://www.tutorialspoint.com/java/java_applet_basics.htm">tutorialspoint</a>)<br/><br/>
            <p>An <b>applet</b> is a Java program that runs in a Web browser. An applet can be a fully functional Java application because it has the 
                entire Java API at its disposal.</p>
                    
            <p>There are some important differences between an applet and a standalone Java application, including the following</p>
            <ul>
                <li>An applet is a Java class that extends the <font color="red"><b>java.applet.Applet</b></font> class.</li>
                <li>A main() method is not invoked on an applet, and an applet class will not define main().</li>
                <li>Applets are designed to be embedded within an HTML page.</li>
                <li>When a user views an HTML page that contains an applet, the code for the applet is downloaded to the user's machine.</li>
                <li>A JVM is required to view an applet. The JVM can be either a plug-in of the Web browser or a separate runtime environment.</li>
                <li>The JVM on the user's machine creates an instance of the applet class and invokes various methods during the applet's lifetime.</li>
                <li>Applets have strict security rules that are enforced by the Web browser. The security of an applet is often referred to as sandbox security, comparing the applet to a 
                    child playing in a sandbox with various rules that must be followed.</li>
                <li>Other classes that the applet needs can be downloaded in a single Java Archive (JAR) file.</li>
            </ul>

            <h3 class="mainPoint">Life Cycle of an Applet</h3>
            <p>Four methods in the Applet class gives you the framework on which you build any serious applet</p>
            <ul>
                <li><b>init</b> - This method is intended for whatever initialization is needed for your applet. It is called after the param tags 
                    inside the applet tag have been processed.</li>
                <li><b>start</b> - This method is automatically called after the browser calls the init method. It is also called whenever the user 
                    returns to the page containing the applet after having gone off to other pages.</li>
                <li><b>stop</b> - This method is automatically called when the user moves off the page on which the applet sits. It can, therefore, 
                    be called repeatedly in the same applet.</li>
                <li><b>destroy</b> - This method is only called when the browser shuts down normally. Because applets are meant to live on an HTML 
                    page, you should not normally leave resources behind after a user leaves the page that contains the applet.</li>
                <li><b>paint</b> - Invoked immediately after the start() method, and also any time the applet needs to repaint itself in the browser. 
                    The paint() method is actually inherited from the <font color="red"><b>java.awt</b></font>.</li>
            </ul>

            <br/><p align="right">(<a href="#tableOfContent">Table of Content</a>)</p><hr/>
            <!-- *************************************************************************** -->
            <!-- *************************************************************************** -->
            <span class="part" id="java_documentation">Documentation</span>  (source: <a href="https://www.tutorialspoint.com/java/java_documentation.htm">tutorialspoint</a>)<br/><br/>
            <p>Javadoc is a tool which comes with JDK and it is used for generating Java code documentation in HTML format from Java source code, 
                which requires documentation in a predefined format.</p>

            <p align="right">(<a href="#tableOfContent">Table of Content</a>)</p>
        </div>
    </div>
</div>
</body>
</html>
